{
  "hash": "64daf59ccf251e98ec2d66fc56c0f90b",
  "result": {
    "markdown": "---\ntitle: \"Non Linear Local Projections\"\nauthor: \"Andro Asatashvili\"\ntoc: true\ncode-annotations: hover\n---\n\n\n# Non Linear Local Projections with Insrumental Variable Identification\n\nThis script details the main graphs and function used in my undergraduate dissertation.\n\nThis dissertation researches the dynamics of US inflation using a novel nonlinear local projections framework. We highlight the roles of the global supply chain and consumer debt levels in monetary policy efficacy. In order to do this, we establish four regimes, constructed on transition probabilities based on the interaction of the aforementioned variables, which are known as trigger variables. This means that we asses monetary policy effectiveness on whether there's stress in the global supply chain and simultaneously, high consumer debt levels. Hence, whilst focusing on implementing two trigger variables instead of the literature's use of one, we find that monetary policy is limited under high supply chain stress, irrespective of consumer debt levels. Conversely, in low-stress environments, monetary policy consistently proves more successful when consumer debt is high. Utilising the Global Supply Chain Pressure Index and Total Consumer Credit as proxies for our trigger variables, the results call attention to the interplay between supply-side exogenous constraints and demand-side transmission mechanisms in shaping inflation dynamics in the US.\n\n## Packages and FRED API:\n\nWe obtain the data from FRED's API\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrm(list = ls())\n\nlibrary(tidyverse)\nlibrary(fredr)\nlibrary(readxl)\n\nkey <- \"c27bf13d09598a184acdcb2ba94aa28f\" # <1>\nfredr_set_key(key)                        # <1>\nfredr_has_key()                           # <1>\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\n1.  Personalized key. You can create your own in https://fred.stlouisfed.org/. `fredr_has_key` checks whether API key exists.\n\n## Data:\n\nSeries_id available on FRED.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Industrial Production \nINDPROD <- fredr_series_observations(series_id = \"INDPRO\",\n                                     observation_start = as.Date(\"1997-08-01\"),\n                                     observation_end = as.Date(\"2024-03-31\"),\n                                     frequency = \"m\",\n                                     aggregation_method = \"avg\",\n                                     units = \"lin\") %>%\n  rename(INDPROD = value) %>%\n  mutate(ldINDPROD = log(INDPROD),\n         ldINDPROD = 100 * (ldINDPROD - lag(ldINDPROD))) %>%\n  select(date, ldINDPROD)\n\n# Consumer Prices\ncpi <- fredr_series_observations(series_id = \"CPIAUCSL\",\n                                 observation_start = as.Date(\"1997-08-01\"),\n                                 observation_end = as.Date(\"2024-03-31\"),\n                                 frequency = \"m\",\n                                 aggregation_method = \"sum\",\n                                 units = \"lin\") %>%\n  rename(cpi = value) %>%\n  mutate(lcpi = log(cpi),\n         ldcpi = 100 * (lcpi - lag(lcpi))) %>%\n  select(date, lcpi, ldcpi)\n\n# Producer Prices\nppi <- fredr_series_observations(series_id = \"PPIIDC\",\n                                 observation_start = as.Date(\"1997-08-01\"),\n                                 observation_end = as.Date(\"2024-03-31\"),\n                                 frequency = \"m\",\n                                 aggregation_method = \"avg\",\n                                 units = \"lin\") %>%\n  rename(ppi = value) %>%\n  mutate(lppi = log(ppi),\n         ldppi = 100 * (lppi - lag(lppi))) %>%\n  select(date, ldppi)\n\n# 1-Year Inflation Expectations\nEXPINF1YR <- fredr_series_observations(series_id = \"EXPINF1YR\",\n                                       observation_start = as.Date(\"1997-08-01\"),\n                                       observation_end = as.Date(\"2024-03-31\"),\n                                       frequency = \"m\",\n                                       aggregation_method = \"avg\",\n                                       units = \"lin\") %>%\n  rename(dEXPINF1YR = value) %>%\n  select(date, dEXPINF1YR)\n\n# 10-Year Treasury Rate \nDGS10 <- fredr_series_observations(series_id = \"DGS10\",\n                                   observation_start = as.Date(\"1997-08-01\"),\n                                   observation_end = as.Date(\"2024-03-31\"),\n                                   frequency = \"m\",\n                                   aggregation_method = \"avg\",\n                                   units = \"lin\") %>%\n  rename(dDGS10 = value) %>%\n  select(date, dDGS10)\n\n# 1-Year Treasury Rate \nDGS1 <- fredr_series_observations(series_id = \"DGS1\",\n                                  observation_start = as.Date(\"1997-08-01\"),\n                                  observation_end = as.Date(\"2024-03-31\"),\n                                  frequency = \"m\",\n                                  aggregation_method = \"avg\",\n                                  units = \"lin\") %>%\n  rename(dDGS1 = value) %>%\n  select(date, dDGS1)\n\n# 5-Year Treasury Rate \nDGS5 <- fredr_series_observations(series_id = \"DGS5\",\n                                  observation_start = as.Date(\"1997-08-01\"),\n                                  observation_end = as.Date(\"2024-03-31\"),\n                                  frequency = \"m\",\n                                  aggregation_method = \"avg\",\n                                  units = \"lin\") %>%\n  rename(dDGS5 = value) %>%\n  select(date, dDGS5)\n\n# 30-Year Treasury Rate \nDGS30 <- fredr_series_observations(series_id = \"DGS30\",\n                                   observation_start = as.Date(\"1997-08-01\"),\n                                   observation_end = as.Date(\"2024-03-31\"),\n                                   frequency = \"m\",\n                                   aggregation_method = \"avg\",\n                                   units = \"lin\") %>%\n  rename(dDGS30 = value) %>%\n  select(date, dDGS30)\n\n# BAA10Y \nBAA10Y <- fredr_series_observations(series_id = \"BAA10Y\",\n                                    observation_start = as.Date(\"1997-08-01\"),\n                                    observation_end = as.Date(\"2024-03-31\"),\n                                    frequency = \"m\",\n                                    aggregation_method = \"avg\",\n                                    units = \"lin\") %>%\n  rename(dBAA10Y = value) %>%\n  select(date, dBAA10Y)\n\n# Economic Activity Index \neconacti <- fredr_series_observations(series_id = \"USPHCI\",\n                                      observation_start = as.Date(\"1997-08-01\"),\n                                      observation_end = as.Date(\"2024-03-31\"),\n                                      frequency = \"m\",\n                                      aggregation_method = \"avg\",\n                                      units = \"lin\") %>%\n  rename(econacti = value) %>%\n  mutate(leconacti = log(econacti),\n         ldeconacti = 100 * (leconacti - lag(leconacti))) %>%\n  select(date, ldeconacti)\n\n# Volatility Index \nVIX <- fredr_series_observations(series_id = \"VIXCLS\",\n                                 observation_start = as.Date(\"1997-08-01\"),\n                                 observation_end = as.Date(\"2024-03-31\"),\n                                 frequency = \"m\",\n                                 aggregation_method = \"avg\",\n                                 units = \"lin\") %>%\n  rename(VIX = value) %>%\n  mutate(lvix = log(VIX),\n         ldvix = 100 * (lvix - lag(lvix))) %>%\n  select(date, ldvix)\n\n\ndf <- cpi %>%                                                        # <1>\n  left_join(INDPROD, by = \"date\") %>%\n  left_join(ppi, by = \"date\") %>%\n  left_join(EXPINF1YR, by = \"date\") %>%\n  mutate(dEXPINF1YR = dEXPINF1YR - lag(dEXPINF1YR)) %>%\n  left_join(DGS10, by = \"date\") %>%\n  mutate(dDGS10 = dDGS10 - lag(dDGS10)) %>%\n  left_join(DGS1, by = \"date\") %>%\n  mutate(dDGS1 = dDGS1 - lag(dDGS1)) %>%\n  left_join(DGS5, by = \"date\") %>%\n  mutate(dDGS5 = dDGS5 - lag(dDGS5)) %>%\n  left_join(DGS30, by = \"date\") %>%\n  mutate(dDGS30 = dDGS30 - lag(dDGS30)) %>%\n  left_join(BAA10Y, by = \"date\") %>%\n  mutate(dBAA10Y = dBAA10Y - lag(dBAA10Y)) %>%\n  left_join(econacti, by = \"date\") %>%\n  left_join(VIX, by = \"date\") %>%\n  mutate(ldvix = ldvix - lag(ldvix))\n                                                                    # <1>\ndf <- df[-1, ]\nhead(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 13\n  date        lcpi  ldcpi ldINDPROD   ldppi dEXPINF1YR  dDGS10   dDGS1   dDGS5\n  <date>     <dbl>  <dbl>     <dbl>   <dbl>      <dbl>   <dbl>   <dbl>   <dbl>\n1 1997-09-01  5.08 0.248      0.919  0.314     0.0443  -0.0900 -0.0400 -0.0500\n2 1997-10-01  5.08 0.186      0.889  0.313    -0.0254  -0.180  -0.0600 -0.180 \n3 1997-11-01  5.09 0.124      0.796  0.0780   -0.0554  -0.150   0      -0.130 \n4 1997-12-01  5.09 0.0618     0.427 -0.940     0.00271 -0.0700  0.0700 -0.0300\n5 1998-01-01  5.09 0.124      0.443 -0.870    -0.178   -0.270  -0.29   -0.350 \n6 1998-02-01  5.09 0          0.178 -0.478    -0.139    0.0300  0.0700  0.0700\n# ℹ 4 more variables: dDGS30 <dbl>, dBAA10Y <dbl>, ldeconacti <dbl>,\n#   ldvix <dbl>\n```\n:::\n:::\n\n\n1.  We join the variables and create some that will be useful as well\n\n## Regime variables\n\nWhere $z_{t}$ is any given trigger variable. The logistic probability function enables us to avoid using a dummy approach, which allows the use of all observations. Although in some cases its suitable to think of a binary trigger variable, the data is separated into two independent regimes, lowering the degrees of freedom and data coverage. As well, a nice feature is that the transformed trigger variable would now have $Var(z_{t}) = 1$ and $E(z_{t}) = 0$. The logistic probability density function has curvature parameter $\\kappa > 0$, which captures the regime-switching behaviour of the trigger variable. As a baseline, we use $\\kappa = 6$ for both trigger variables. Moreover, $F(\\cdot)$ can have the lag of the trigger variable ($z_{t-1}$) as its input. This is done to avoid feedback. Lastly, we use the Hodrick-Prescott (HP) filter, as recommended by \\citet{auerbach2012measuring}, to remove the cyclical component of the trigger variable. For the decomposition parameter $\\lambda$ of the HP filter, we use $\\lambda = 129,600$ for monthly data. This allows us to obtain a smoothed-curve representation of the trigger, which becomes more sensible to long-term fluctuations. Thus, we capture the dynamics with our respective triggers with non-linear local projections (NLLP).\n\n\n```{=tex}\n\\begin{equation} \n    F(z_{t-1}) = \\frac{\\exp^{-\\kappa z_{t-1}}}{1 + \\exp^{-\\kappa z_{t-1}}}\n\\end{equation}\n```\n\n::: {.cell}\n\n```{.r .cell-code}\ntrigger_z <- function(z, specs) {\n  \n  specs <- list()\n  specs$lambda_z        <- lambda_z\n  specs$gamma_z         <- gamma_z\n  specs$use_hp_z        <- use_hp_z\n  specs$lag_switching_z <- lag_switching_z\n  z                     <- as.data.frame(z)\n  names(z)              <- \"z_var\"\n  \n  if (specs$use_hp_z == TRUE) {\n    \n    filter_results_z <- lpirfs::hp_filter(as.matrix(z), specs$lambda_z)\n    gamma_z          <- specs$gamma_z\n    z_0_z            <- as.numeric(scale(filter_results_z[[1]], center = TRUE))\n    fz_z             <- 1 - exp(-gamma_z * z_0_z) / (1 + exp(-gamma_z * z_0_z))\n    \n    if (isTRUE(specs$lag_switching_z)) {\n      fz_z <- 1 - exp(-gamma_z * dplyr::lag(z_0_z, 1)) / \n              (1 + exp(-gamma_z * dplyr::lag(z_0_z, 1)))\n    }\n    \n  } else {\n    \n    fz_z <- 1 - exp(-specs$gamma_z * z$z_var) / (1 + exp(-specs$gamma_z * z$z_var))\n    \n    if (isTRUE(specs$lag_switching_z)) {\n      fz_z <- dplyr::lag(fz_z, 1)\n    }\n    \n  }\n  \n  return(fz_z)\n}\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}